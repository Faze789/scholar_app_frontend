import 'dart:io';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:go_router/go_router.dart';
import 'package:image_picker/image_picker.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

class StudentSignUpScreen extends StatefulWidget {
  const StudentSignUpScreen({super.key});

  @override
  State<StudentSignUpScreen> createState() => _StudentSignUpScreenState();
}

class _StudentSignUpScreenState extends State<StudentSignUpScreen> {
  final _formKey = GlobalKey<FormState>();
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  // Form fields
  String name = '';
  String fatherName = '';
  String matricMarks = '';
  String fscMarks = '';
  String oLevelMarks = '';
  String aLevelMarks = '';
  String ntsMarks = '';
  String netMarks = '';
  String ecatMarks = '';
  String nedMarks = '';
  String cgpa = '';
  String email = '';
  String password = '';
  bool isBS = false;
  bool isMS = false;
  bool isOALevel = false;
  File? _profileImage;
  List<String> selectedFields = [];
  Map<String, dynamic>? apiResponseData;

  final List<String> bsFields = [
    "Computer Science",
    "Software Engineering",
    "Electrical Engineering",
    "Business Administration"
  ];

  final List<String> msFields = [
    "Data Science",
    "AI & Machine Learning",
    "MBA"
  ];

  
  static const String otpServerUrl = 'http://192.168.100.121:3001';

  Future<void> _pickImage() async {
    final pickedFile = await ImagePicker().pickImage(source: ImageSource.gallery);
    if (pickedFile != null) {
      setState(() {
        _profileImage = File(pickedFile.path);
      });
    }
  }

  Future<String?> _uploadToCloudinary(File file) async {
    const cloudName = 'dwcsrl6tl';
    const uploadPreset = 'images';
    final url = Uri.parse('https://api.cloudinary.com/v1_1/$cloudName/image/upload');

    final request = http.MultipartRequest('POST', url)
      ..fields['upload_preset'] = uploadPreset
      ..files.add(await http.MultipartFile.fromPath('file', file.path));

    try {
      final response = await request.send();
      final resStr = await response.stream.bytesToString();
      final data = json.decode(resStr);

      if (response.statusCode == 200) {
        print('Image uploaded to Cloudinary: ${data['secure_url']}');
        return data['secure_url'];
      } else {
        print('Cloudinary Upload Failed: ${data['error']}');
        return null;
      }
    } catch (e) {
      print('Error uploading to Cloudinary: $e');
      return null;
    }
  }

Future<bool> _callPredictionAPI() async {
  try {
   
    double matric, fsc;
    
    if (isOALevel) {
      
      matric = (double.tryParse(oLevelMarks) ?? 0) / 900 * 1100;
      fsc = (double.tryParse(aLevelMarks) ?? 0) / 1200 * 1100;
      print('üîÑ Converting O/A Level marks for API: O-Level($oLevelMarks/900) -> Matric($matric/1100), A-Level($aLevelMarks/1200) -> FSC($fsc/1100)');
    } else {
     
      matric = double.tryParse(matricMarks) ?? 0;
      fsc = double.tryParse(fscMarks) ?? 0;
      print('üîÑ Using original Matric/FSC marks for API: Matric($matricMarks), FSC($fscMarks)');
    }
    
    double ecat = double.tryParse(ecatMarks) ?? 0;
    double nts = double.tryParse(ntsMarks) ?? 0;
    double net = double.tryParse(netMarks) ?? 0;
    double ned = double.tryParse(nedMarks) ?? 0;

    String program = selectedFields.isNotEmpty ? selectedFields.first : (isBS ? 'BS' : 'MS');

    final url = Uri.parse("http://192.168.100.121:5000/predict");
    
    print('Making API call to: $url');
    print('Request data: ${json.encode({
      "matric_marks": matric,
      "fsc_marks": fsc,
      "nts_marks": nts,
      "net_marks": net,
      "ecat_marks": ecat,
      "ned_test_marks": ned,
      "program": program,
    })}');

    final response = await http.post(
      url,
      headers: {"Content-Type": "application/json"},
      body: json.encode({
        "matric_marks": matric,
        "fsc_marks": fsc,
        "nts_marks": nts,
        "net_marks": net,
        "ecat_marks": ecat,
        "ned_test_marks": ned,
        "program": program,
      }),
    ).timeout(const Duration(seconds: 30));

    print('API Response Status: ${response.statusCode}');
    print('API Response Body: ${response.body}');

    if (response.statusCode == 200) {
      final result = json.decode(response.body);
      
     
      if (result['universities'] == null || result['universities'] is! List) {
        print('‚ùå Invalid API response structure');
        _showErrorDialog("Invalid API response structure");
        return false;
      }

      print('‚úÖ API call successful, universities found: ${result['universities'].length}');
      
      setState(() {
        apiResponseData = result;
      });
      return true;
    } else {
      print('‚ùå API Error: ${response.statusCode}');
      _showErrorDialog("API Error: ${response.statusCode}\n${response.body}");
      return false;
    }
  } catch (e) {
    print('‚ùå API call failed: $e');
    _showErrorDialog("API call failed: $e");
    return false;
  }
}
  Future<void> _saveStudentData() async {
    if (!_formKey.currentState!.validate()) return;
    

    if (!isBS && !isMS) {
      _showErrorDialog("Please select either BS or MS program");
      return;
    }

    _formKey.currentState!.save();

  
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (ctx) => const AlertDialog(
        content: Row(
          children: [
            CircularProgressIndicator(),
            SizedBox(width: 20),
            Text("Processing..."),
          ],
        ),
      ),
    );

    try {
      print('üîÑ Starting registration process...');

      
      String? imageUrl;
      if (_profileImage != null) {
        print('üîÑ Uploading image to Cloudinary...');
        imageUrl = await _uploadToCloudinary(_profileImage!);
        if (imageUrl == null) {
          Navigator.pop(context);
          _showErrorDialog("Failed to upload image to Cloudinary.");
          return;
        }
        print('‚úÖ Image uploaded successfully: $imageUrl');
      }


      print('üîÑ Calling prediction API...');
      final apiSuccess = await _callPredictionAPI();
      if (!apiSuccess) {
        Navigator.pop(context);
        return;
      }
      print('‚úÖ API call successful');

      
      Navigator.pop(context);

   
      print('üîÑ Sending OTP...');
      final otpSent = await _sendOtp();
      if (!otpSent) {
        return;
      }

      
      final verified = await _showOtpDialog();
      if (!verified) {
        return;
      }


      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (ctx) => const AlertDialog(
          content: Row(
            children: [
              CircularProgressIndicator(),
              SizedBox(width: 20),
              Text("Saving data..."),
            ],
          ),
        ),
      );

      print('üîÑ Preparing student data...');
      final studentData = _prepareStudentData(imageUrl);
      print('‚úÖ Student data prepared');

      print('üîÑ Saving to Firestore...');
      final docRef = await _firestore.collection('students_data').add(studentData)
          .timeout(const Duration(seconds: 30));
      print('‚úÖ Document saved with ID: ${docRef.id}');

      // Verify saved data (optional)
      print('üîÑ Verifying saved data...');
      final savedDoc = await docRef.get().timeout(const Duration(seconds: 15));
      if (!savedDoc.exists) {
        throw Exception("Document not found after saving");
      }
      print('‚úÖ Data verification successful');

    
      Navigator.pop(context);
      
   
      _showSuccessDialog();

    } catch (e) {
      print('‚ùå Registration failed: $e');
      Navigator.pop(context);
      _showErrorDialog("Registration failed: $e");
    }
  }

  String? _otpId;

  Future<bool> _sendOtp() async {
    try {
      final response = await http.post(
        Uri.parse('$otpServerUrl/send-otp'),
        headers: {"Content-Type": "application/json"},
        body: json.encode({"email": email}),
      ).timeout(const Duration(seconds: 10));

      print('Send OTP Response: ${response.statusCode} - ${response.body}');

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        if (data['success'] == true) {
          _otpId = data['otpId'];
          print('‚úÖ OTP sent successfully, otpId: $_otpId');
          return true;
        }
      }

      _showErrorDialog("Failed to send OTP: ${response.body}");
      return false;
    } catch (e) {
      print('‚ùå Send OTP failed: $e');
      _showErrorDialog("Failed to send OTP: $e");
      return false;
    }
  }

  Future<bool> _verifyOtp(String enteredOtp) async {
    try {
      final response = await http.post(
        Uri.parse('$otpServerUrl/verify-otp'),
        headers: {"Content-Type": "application/json"},
        body: json.encode({
          "otpId": _otpId,
          "otp": enteredOtp,
          "email": email,
        }),
      ).timeout(const Duration(seconds: 10));

      print('Verify OTP Response: ${response.statusCode} - ${response.body}');

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        if (data['success'] == true) {
          print('‚úÖ OTP verified successfully');
          return true;
        }
      }

      _showErrorDialog("OTP verification failed: ${json.decode(response.body)['error'] ?? response.body}");
      return false;
    } catch (e) {
      print('‚ùå Verify OTP failed: $e');
      _showErrorDialog("OTP verification failed: $e");
      return false;
    }
  }

  Future<bool> _showOtpDialog() async {
    final otpController = TextEditingController();
    bool isVerifying = false;

    return await showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (ctx) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              title: const Text("Verify OTP"),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Text("Enter the OTP sent to your email."),
                  const SizedBox(height: 10),
                  TextField(
                    controller: otpController,
                    keyboardType: TextInputType.number,
                    decoration: const InputDecoration(
                      labelText: 'OTP',
                      border: OutlineInputBorder(),
                    ),
                  ),
                  if (isVerifying)
                    const Padding(
                      padding: EdgeInsets.only(top: 10),
                      child: CircularProgressIndicator(),
                    ),
                ],
              ),
              actions: [
                TextButton(
                  onPressed: isVerifying ? null : () => Navigator.pop(ctx, false),
                  child: const Text("Cancel"),
                ),
                ElevatedButton(
                  onPressed: isVerifying
                      ? null
                      : () async {
                          if (otpController.text.isEmpty) {
                            _showErrorDialog("Please enter OTP");
                            return;
                          }
                          setDialogState(() => isVerifying = true);
                          final verified = await _verifyOtp(otpController.text);
                          setDialogState(() => isVerifying = false);
                          if (verified) {
                            Navigator.pop(ctx, true);
                          }
                        },
                  child: const Text("Verify"),
                ),
              ],
            );
          },
        );
      },
    ) ?? false;
  }

  Map<String, dynamic> _prepareStudentData(String? imageUrl) {
  Map<String, dynamic> data = {
    'student_name': name,
    'father_name': fatherName,
    'email': email,
    'password': password, 
    'profile_image_url': imageUrl,
    'submission_date': FieldValue.serverTimestamp(),
    'is_o_a_level': isOALevel,
    'program': isBS ? 'BS' : 'MS',
    'selected_fields': selectedFields,
  };

 
  if (isOALevel) {
  
    data.addAll({
      'o_level_marks': double.tryParse(oLevelMarks) ?? 0,
      'a_level_marks': double.tryParse(aLevelMarks) ?? 0,
      'matric_marks': null,  
      'fsc_marks': null,     
    });
    
    print('‚úÖ O/A Level Student - Saving: O-Level=$oLevelMarks, A-Level=$aLevelMarks, Matric=null, FSC=null');
  } else {
   
    data.addAll({
      'matric_marks': double.tryParse(matricMarks) ?? 0,
      'fsc_marks': double.tryParse(fscMarks) ?? 0,
      'o_level_marks': null,    
      'a_level_marks': null,   
    });
    
    print('‚úÖ Matric/FSC Student - Saving: Matric=$matricMarks, FSC=$fscMarks, O-Level=null, A-Level=null');
  }

  
  data.addAll({
    'nts_marks': double.tryParse(ntsMarks) ?? 0,
    'net_marks': double.tryParse(netMarks) ?? 0,
    'ecat_marks': double.tryParse(ecatMarks) ?? 0,
    'ned_marks': double.tryParse(nedMarks) ?? 0,
    'cgpa': isMS ? double.tryParse(cgpa) : null,
  });

  
  if (apiResponseData != null && apiResponseData!['universities'] is List) {
    try {
      List<dynamic> universities = apiResponseData!['universities'];
      print('üìä Processing ${universities.length} universities data...');
      
      for (var uni in universities) {
        if (uni == null) continue;
        
        String uniId = (uni['id']?.toString() ?? 'unknown').toLowerCase();
        String uniName = uni['name'] ?? 'Unknown';
        
        print('üè´ Processing data for: $uniName (ID: $uniId)');
        
        
        data.addAll({
          '${uniId}_name': uniName,
          '${uniId}_predicted_2026_aggregate': uni['predicted_2026_cutoff'],
          '${uniId}_student_aggregate': uni['user_aggregate'],
          '${uniId}_last_year_aggregate': uni['last_actual_cutoff'],
          '${uniId}_last_actual_year': uni['last_actual_year'],
          '${uniId}_admission_chance': uni['admission_chance'],
          '${uniId}_admitted': uni['admitted'],
        });

       
        if (uni['criteria'] != null) {
          Map<String, dynamic> criteria = uni['criteria'];
          data.addAll({
            '${uniId}_test_used': criteria['test_used'],
          });

          
          if (criteria['weights'] != null) {
            Map<String, dynamic> weights = criteria['weights'];
            data.addAll({
              '${uniId}_criteria_weights': weights,
            });
          }

         
          if (criteria['totals'] != null) {
            Map<String, dynamic> totals = criteria['totals'];
            data.addAll({
              '${uniId}_criteria_totals': totals,
            });
          }
        }

      
        switch (uniId) {
          case 'iiui':
            print('‚úÖ IIUI data processed successfully');
            data.addAll({
              'iiui_processed': true,
              'iiui_processing_date': FieldValue.serverTimestamp(),
            });
            break;
            
          case 'ned':
            print('‚úÖ NED data processed successfully');
            break;
            
          case 'nust':
            print('‚úÖ NUST data processed successfully');
            break;
            
          case 'comsats':
            print('‚úÖ COMSATS data processed successfully');
            break;
            
          case 'fast':
            print('‚úÖ FAST data processed successfully');
            break;
            
          case 'uet':
            print('‚úÖ UET data processed successfully');
            break;
            
          case 'bahria':
            print('‚úÖ Bahria data processed successfully');
            break;
            
          case 'iqra':
            print('‚úÖ Iqra data processed successfully');
            break;
            
          default:
            print('‚úÖ $uniName data processed successfully');
        }
      }

     
      data.addAll({
        'total_universities_processed': universities.length,
        'universities_list': universities.map((uni) => {
          'id': uni['id'],
          'name': uni['name'],
          'admitted': uni['admitted'],
          'admission_chance': uni['admission_chance'],
        }).toList(),
      });

      print('‚úÖ All university data processed successfully');
      
    } catch (e) {
      print('‚ö†Ô∏è Warning: Error processing API response data: $e');
     
      data.addAll({
        'api_processing_error': e.toString(),
        'api_processing_timestamp': FieldValue.serverTimestamp(),
      });
    }
  } else {
    print('‚ö†Ô∏è No API response data available');
    data['api_data_available'] = false;
  }

  print('üî• FINAL DATA STRUCTURE:');
  print('is_o_a_level: ${data['is_o_a_level']}');
  print('matric_marks: ${data['matric_marks']}');
  print('fsc_marks: ${data['fsc_marks']}');
  print('o_level_marks: ${data['o_level_marks']}');
  print('a_level_marks: ${data['a_level_marks']}');

  return data;
}

  void _showSuccessDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (ctx) => AlertDialog(
        title: const Text("Registration Successful"),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text("$name has been registered successfully!"),
            const SizedBox(height: 10),
            if (apiResponseData != null && apiResponseData!['universities'] != null) ...[
              Text("${(apiResponseData!['universities'] as List).length} universities analyzed"),
              const SizedBox(height: 5),
          
              ...((apiResponseData!['universities'] as List)
                  .where((uni) => uni['admitted'] == true)
                  .map((uni) => Text("‚úÖ Admitted: ${uni['name']}", 
                      style: const TextStyle(color: Colors.green, fontSize: 12)))
                  .toList()),
            ],
          ],
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(ctx);
              context.go('/student_login');
            },
            child: const Text("OK"),
          )
        ],
      ),
    );
  }

  void _showErrorDialog(String message) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text("Error"),
        content: SingleChildScrollView(
          child: Text(message),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx),
            child: const Text("OK"),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        padding: const EdgeInsets.all(20),
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: [Colors.blue.shade900, Colors.purple.shade700],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: SingleChildScrollView(
            child: Form(
              key: _formKey,
              child: Column(
                children: [
                  const SizedBox(height: 30),
                  GestureDetector(
                    onTap: _pickImage,
                    child: CircleAvatar(
                      radius: 50,
                      backgroundColor: Colors.white,
                      backgroundImage: _profileImage != null
                          ? FileImage(_profileImage!)
                          : null,
                      child: _profileImage == null
                          ? const Icon(Icons.camera_alt, size: 40, color: Colors.deepPurple)
                          : null,
                    ),
                  ),
                  const SizedBox(height: 20),
                  const Text(
                    'Student Registration',
                    style: TextStyle(fontSize: 26, fontWeight: FontWeight.bold, color: Colors.white),
                  ),
                  const SizedBox(height: 30),
                  _buildTextField(label: 'Full Name', onSaved: (v) => name = v!),
                  _buildTextField(label: 'Father Name', onSaved: (v) => fatherName = v!),
                  Row(
                    children: [
                      const Text("O/A Level?", style: TextStyle(color: Colors.white)),
                      Switch(
                        value: isOALevel,
                        onChanged: (v) => setState(() => isOALevel = v),
                      ),
                    ],
                  ),
                  if (isOALevel) ...[
                    _buildTextField(
                      label: 'O Level Marks (out of 900)',
                      keyboardType: TextInputType.number,
                      onSaved: (v) => oLevelMarks = v!,
                    ),
                    _buildTextField(
                      label: 'A Level Marks (out of 1200)',
                      keyboardType: TextInputType.number,
                      onSaved: (v) => aLevelMarks = v!,
                    ),
                  ] else ...[
                    _buildTextField(
                      label: 'Matric Marks (out of 1100)',
                      keyboardType: TextInputType.number,
                      onSaved: (v) => matricMarks = v!,
                    ),
                    _buildTextField(
                      label: 'FSC Marks (out of 1100)',
                      keyboardType: TextInputType.number,
                      onSaved: (v) => fscMarks = v!,
                    ),
                  ],
                  _buildTextField(
                    label: 'NTS Marks (out of 100)',
                    keyboardType: TextInputType.number,
                    onSaved: (v) => ntsMarks = v!,
                  ),
                  _buildTextField(
                    label: 'NET Marks (out of 200)',
                    keyboardType: TextInputType.number,
                    onSaved: (v) => netMarks = v!,
                  ),
                  _buildTextField(
                    label: 'ECAT Marks (out of 400)',
                    keyboardType: TextInputType.number,
                    onSaved: (v) => ecatMarks = v!,
                  ),
                  _buildTextField(
                    label: 'NED Entry Test Marks (out of 100)',
                    keyboardType: TextInputType.number,
                    onSaved: (v) => nedMarks = v!,
                    helperText: 'Required for NED University admission prediction',
                  ),
                  if (isMS)
                    _buildTextField(
                      label: 'CGPA',
                      keyboardType: TextInputType.number,
                      onSaved: (v) => cgpa = v!,
                    ),
                  _buildTextField(
                    label: 'Email',
                    keyboardType: TextInputType.emailAddress,
                    onSaved: (v) => email = v!,
                    validator: (v) => v!.contains('@') ? null : 'Enter valid email',
                  ),
                  _buildTextField(
                    label: 'Password',
                    obscureText: true,
                    onSaved: (v) => password = v!,
                    validator: (v) {
                      if (v == null || v.isEmpty) return 'Please enter a password';
                      if (v.length < 6) return 'Password must be at least 6 characters';
                      return null;
                    },
                  ),
                  Row(
                    children: [
                      Checkbox(
                        value: isBS,
                        onChanged: (v) => setState(() {
                          isBS = v!;
                          if (isBS) isMS = false;
                          selectedFields.clear();
                        }),
                      ),
                      const Text('BS', style: TextStyle(color: Colors.white)),
                      Checkbox(
                        value: isMS,
                        onChanged: (v) => setState(() {
                          isMS = v!;
                          if (isMS) isBS = false;
                          selectedFields.clear();
                        }),
                      ),
                      const Text('MS', style: TextStyle(color: Colors.white)),
                    ],
                  ),
                  if (isBS || isMS)
                    Column(
                      children: (isBS ? bsFields : msFields).map((field) {
                        return CheckboxListTile(
                          title: Text(field, style: const TextStyle(color: Colors.white)),
                          value: selectedFields.contains(field),
                          onChanged: (v) => setState(() {
                            v! ? selectedFields.add(field) : selectedFields.remove(field);
                          }),
                        );
                      }).toList(),
                    ),
                  const SizedBox(height: 20),
                  ElevatedButton(
                    onPressed: _saveStudentData,
                    child: const Text('Register'),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildTextField({
    required String label,
    TextInputType keyboardType = TextInputType.text,
    bool obscureText = false,
    required FormFieldSetter<String> onSaved,
    FormFieldValidator<String>? validator,
    String? helperText,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 10),
      child: TextFormField(
        style: const TextStyle(color: Colors.white),
        obscureText: obscureText,
        keyboardType: keyboardType,
        decoration: InputDecoration(
          labelText: label,
          helperText: helperText,
          helperStyle: const TextStyle(color: Colors.white70),
          labelStyle: const TextStyle(color: Colors.white),
          enabledBorder: const OutlineInputBorder(
            borderSide: BorderSide(color: Colors.white70),
          ),
          focusedBorder: const OutlineInputBorder(
            borderSide: BorderSide(color: Colors.white),
          ),
        ),
        validator: validator ?? (v) => v!.isEmpty ? 'Required field' : null,
        onSaved: onSaved,
      ),
    );
  }
}


---------------------


import 'dart:io';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:go_router/go_router.dart';
import 'package:image_picker/image_picker.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';

class AlumniSignUp extends StatefulWidget {
  const AlumniSignUp({super.key});

  @override
  State<AlumniSignUp> createState() => _AlumniSignUpState();
}

class _AlumniSignUpState extends State<AlumniSignUp> {
  final _formKey = GlobalKey<FormState>();

  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _gmailController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  final TextEditingController _bsCgpaController = TextEditingController();
  final TextEditingController _msCgpaController = TextEditingController();
  final TextEditingController _instituteController = TextEditingController();
  final TextEditingController _fieldController = TextEditingController();
  final TextEditingController _otpController = TextEditingController(); 

  File? _imageFile;
  final picker = ImagePicker();

  bool _isLoading = false;
  String? _otpId; 

 
  final String cloudName = 'dwcsrl6tl';
  final String uploadPreset = 'images';

  Future<void> _pickImage() async {
    final pickedFile = await picker.pickImage(source: ImageSource.gallery, imageQuality: 75);

    if (pickedFile != null) {
      setState(() {
        _imageFile = File(pickedFile.path);
      });
    }
  }

  Future<String?> _uploadToCloudinary(File imageFile) async {
    final url = Uri.parse("https://api.cloudinary.com/v1_1/$cloudName/image/upload");

    final request = http.MultipartRequest('POST', url)
      ..fields['upload_preset'] = uploadPreset
      ..files.add(await http.MultipartFile.fromPath('file', imageFile.path));

    final response = await request.send();

    if (response.statusCode == 200) {
      final res = await http.Response.fromStream(response);
      final data = json.decode(res.body);
      return data['secure_url'];
    } else {
      print('Cloudinary upload failed: ${response.statusCode}');
      return null;
    }
  }

  Future<void> _sendOTP(String email) async {
    final otpResponse = await http.post(
      Uri.parse('http://192.168.100.149:3001/send-otp'), 
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({'email': email}),
    );

    if (otpResponse.statusCode == 200) {
      final responseData = jsonDecode(otpResponse.body);
      if (responseData['success']) {
        setState(() {
          _otpId = responseData['otpId'];
        });
        _showOTPDialog(email);
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to send OTP: ${responseData['error']}')),
        );
      }
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Failed to connect to server')),
      );
    }
  }

  Future<void> _verifyOTP(String email, String otp) async {
    if (_otpId == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('OTP ID not found. Please try again.')),
      );
      return;
    }

    final verifyResponse = await http.post(
      Uri.parse('http://192.168.100.149:3001/verify-otp'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({'otpId': _otpId, 'otp': otp, 'email': email}),
    );

    if (verifyResponse.statusCode == 200) {
      final responseData = jsonDecode(verifyResponse.body);
      if (responseData['success']) {
        final imageUrl = await _uploadToCloudinary(_imageFile!);

        if (imageUrl == null) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Image upload failed')),
          );
          return;
        }

        final data = {
          'name': _nameController.text.trim(),
          'gmail': email,
          'password': _passwordController.text.trim(),
          'cgpa_bs': _bsCgpaController.text.trim(),
          'cgpa_ms': _msCgpaController.text.trim(),
          'institute': _instituteController.text.trim(),
          'field': _fieldController.text.trim(),
          'image_url': imageUrl,
          'timestamp': FieldValue.serverTimestamp(),
        };

        await FirebaseFirestore.instance.collection('alumni_data').add(data);

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Alumni Registered Successfully!')),
        );

        context.go('/alumni-signin');
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('OTP verification failed: ${responseData['error']}')),
        );
      }
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Failed to verify OTP')),
      );
    }
  }

  void _showOTPDialog(String email) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Enter OTP'),
        content: TextField(
          controller: _otpController,
          keyboardType: TextInputType.number,
          decoration: const InputDecoration(hintText: 'Enter 6-digit OTP'),
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context); 
            },
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              if (_otpController.text.length == 6) {
                Navigator.pop(context); 
                _verifyOTP(email, _otpController.text.trim());
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Please enter a 6-digit OTP')),
                );
              }
            },
            child: const Text('Verify'),
          ),
        ],
      ),
    );
  }

  Future<void> _registerAlumni() async {
    if (!_formKey.currentState!.validate() || _imageFile == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please fill all fields and select an image')),
      );
      return;
    }

    setState(() {
      _isLoading = true;
    });

    final String email = _gmailController.text.trim();
    await _sendOTP(email);

    setState(() {
      _isLoading = false;
    });
  }

  Widget _buildTextField(TextEditingController controller, String label,
      {bool obscureText = false, TextInputType keyboardType = TextInputType.text}) {
    return TextFormField(
      controller: controller,
      keyboardType: keyboardType,
      obscureText: obscureText,
      style: const TextStyle(color: Colors.white),
      decoration: InputDecoration(
        labelText: label,
        labelStyle: const TextStyle(color: Colors.white70),
        filled: true,
        fillColor: Colors.white.withOpacity(0.1),
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
      ),
      validator: (value) => value == null || value.isEmpty ? 'Please enter $label' : null,
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: [Colors.blue.shade900, Colors.purple.shade700],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: SafeArea(
          child: Center(
            child: SingleChildScrollView(
              child: Form(
                key: _formKey,
                child: Column(
                  children: [
                    const Text(
                      'Alumni Sign Up',
                      style: TextStyle(
                        fontSize: 32,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                    const SizedBox(height: 20),

                    GestureDetector(
                      onTap: _pickImage,
                      child: CircleAvatar(
                        radius: 50,
                        backgroundImage: _imageFile != null ? FileImage(_imageFile!) : null,
                        backgroundColor: Colors.white.withOpacity(0.2),
                        child: _imageFile == null
                            ? const Icon(Icons.camera_alt, size: 40, color: Colors.white)
                            : null,
                      ),
                    ),

                    const SizedBox(height: 20),
                    _buildTextField(_nameController, 'Name'),
                    const SizedBox(height: 15),
                    _buildTextField(_gmailController, 'Gmail', keyboardType: TextInputType.emailAddress),
                    const SizedBox(height: 15),
                    _buildTextField(_passwordController, 'Password', obscureText: true),
                    const SizedBox(height: 15),
                    _buildTextField(_bsCgpaController, 'CGPA in BS', keyboardType: TextInputType.number),
                    const SizedBox(height: 15),
                    _buildTextField(_msCgpaController, 'CGPA in MS', keyboardType: TextInputType.number),
                    const SizedBox(height: 15),
                    _buildTextField(_instituteController, 'Graduated From'),
                    const SizedBox(height: 15),
                    _buildTextField(_fieldController, 'Field of Study'),
                    const SizedBox(height: 30),

                    _isLoading
                        ? const CircularProgressIndicator(color: Colors.white)
                        : ElevatedButton(
                            onPressed: _registerAlumni,
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.white,
                              foregroundColor: Colors.purple.shade700,
                              padding: const EdgeInsets.symmetric(horizontal: 40, vertical: 15),
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(15),
                              ),
                            ),
                            child: const Text(
                              'Register',
                              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                            ),
                          ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}